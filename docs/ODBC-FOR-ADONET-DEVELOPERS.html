<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ODBC for ADO.NET Developers</title>
<style>
body { max-width: 900px; margin: 40px auto; padding: 0 20px; background: #0d1117; color: #c9d1d9; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; line-height: 1.6; }
table { border-collapse: collapse; width: 100%; margin: 16px 0; }
th, td { border: 1px solid #30363d; padding: 8px 12px; text-align: left; }
th { background: #161b22; color: #f0f6fc; }
code { background: #161b22; color: #f0883e; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
pre { background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 16px; overflow-x: auto; }
pre code { background: none; color: #c9d1d9; padding: 0; }
h1, h2, h3 { color: #f0f6fc; border-bottom: 1px solid #30363d; padding-bottom: 8px; }
h1 { font-size: 2em; }
h2 { font-size: 1.5em; margin-top: 2em; }
h3 { font-size: 1.2em; }
hr { border: none; height: 1px; background: #30363d; margin: 2em 0; }
a { color: #58a6ff; }
blockquote { border-left: 4px solid #f0883e; color: #8b949e; margin: 16px 0; padding: 8px 16px; }
</style>
</head>
<body>
<h1 id="odbc-for-ado.net-developers">ODBC for ADO.NET Developers</h1>
<p>You know <code>SqlConnection</code>, <code>SqlCommand</code>, <code>SqlDataReader</code> inside out. You’ve debugged TDS packets and traced parameter encoding through <code>SqlClient</code>. Now you need to understand ODBC — the C API that predates all of it. This guide maps what you already know to the ODBC equivalents, with real C code you can compile and run.</p>
<hr />
<h2 id="the-mental-model">1. The Mental Model</h2>
<p>In ADO.NET, the object hierarchy is:</p>
<pre><code>SqlConnection → SqlCommand → SqlDataReader</code></pre>
<p>In ODBC, it’s:</p>
<pre><code>HENV → HDBC → HSTMT
(Environment → Connection → Statement)</code></pre>
<p>Both are handle-based. The difference: ADO.NET wraps handles in managed objects with finalizers and <code>IDisposable</code>. ODBC gives you raw <code>SQLHANDLE</code> pointers and expects you to allocate, use, and free them yourself.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Concept</th>
<th>ADO.NET</th>
<th>ODBC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Lifetime management</td>
<td>GC + <code>Dispose()</code></td>
<td>Manual <code>SQLAllocHandle</code> / <code>SQLFreeHandle</code></td>
</tr>
<tr class="even">
<td>Error propagation</td>
<td>Exceptions (<code>SqlException</code>)</td>
<td>Return codes + <code>SQLGetDiagRec</code></td>
</tr>
<tr class="odd">
<td>String encoding</td>
<td>UTF-16 internally</td>
<td>ANSI (<code>SQLExecDirect</code>) or UTF-16 (<code>SQLExecDirectW</code>)</td>
</tr>
<tr class="even">
<td>Column indexing</td>
<td>0-based</td>
<td><strong>1-based</strong></td>
</tr>
</tbody>
</table>
<p>Think of ODBC as what you’d get if you took <code>SqlClient</code>, stripped away the managed wrapper, and exposed the wire protocol layer as a C API. The concepts map almost 1:1 — it’s the ergonomics that differ.</p>
<hr />
<h2 id="connecting">2. Connecting</h2>
<h3 id="c-what-you-know">C# — What You Know</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">var</span> connStr = <span class="st">&quot;Data Source=localhost;Initial Catalog=mydb;User ID=sa;Password=secret;TrustServerCertificate=true&quot;</span>;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> conn = <span class="kw">new</span> <span class="fu">SqlConnection</span>(connStr);</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>conn.<span class="fu">Open</span>();</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">// conn is ready</span></span></code></pre></div>
<h3 id="odbc-the-c-equivalent">ODBC — The C Equivalent</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sql.h&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sqlext.h&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>SQLHENV henv = SQL_NULL_HENV;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>SQLHDBC hdbc = SQL_NULL_HDBC;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>SQLRETURN ret;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="co">// Step 1: Allocate environment handle (no ADO.NET equivalent — it&#39;s implicit)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="co">// Step 2: Declare ODBC version (required before any connection)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>ret = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>                    (SQLPOINTER)SQL_OV_ODBC3, <span class="dv">0</span>);</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="co">// Step 3: Allocate connection handle (like `new SqlConnection()`)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>ret = SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="co">// Step 4: Connect (like `.Open()`)</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>SQLCHAR connStr[] = <span class="st">&quot;DRIVER={ODBC Driver 18 for SQL Server};&quot;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>                    <span class="st">&quot;SERVER=localhost;&quot;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>                    <span class="st">&quot;DATABASE=mydb;&quot;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>                    <span class="st">&quot;UID=sa;&quot;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>                    <span class="st">&quot;PWD=secret;&quot;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>                    <span class="st">&quot;TrustServerCertificate=yes;&quot;</span>;</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>SQLCHAR outConnStr[<span class="dv">1024</span>];</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>SQLSMALLINT outConnStrLen;</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a>ret = SQLDriverConnect(hdbc, NULL,</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a>                       connStr, SQL_NTS,</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a>                       outConnStr, <span class="kw">sizeof</span>(outConnStr),</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true"></a>                       &amp;outConnStrLen,</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true"></a>                       SQL_DRIVER_NOPROMPT);</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true"></a><span class="cf">if</span> (ret != SQL_SUCCESS &amp;&amp; ret != SQL_SUCCESS_WITH_INFO) {</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true"></a>    <span class="co">// Handle error (see Section 8)</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true"></a>    fprintf(stderr, <span class="st">&quot;Connection failed</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="connection-string-key-mapping">Connection String Key Mapping</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>ADO.NET (<code>SqlClient</code>)</th>
<th>ODBC</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Data Source</code></td>
<td><code>SERVER</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>Initial Catalog</code></td>
<td><code>DATABASE</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>User ID</code></td>
<td><code>UID</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>Password</code></td>
<td><code>PWD</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>TrustServerCertificate</code></td>
<td><code>TrustServerCertificate</code></td>
<td>Same key, different values: <code>true</code>/<code>false</code> vs <code>yes</code>/<code>no</code></td>
</tr>
<tr class="even">
<td><em>(implicit)</em></td>
<td><code>DRIVER</code></td>
<td>ODBC needs an explicit driver name — no default</td>
</tr>
</tbody>
</table>
<p>The <code>DRIVER</code> key has no ADO.NET equivalent because <code>SqlClient</code> <em>is</em> the driver. In ODBC, the driver is a pluggable shared library, and you pick it by name. For SQL Server, it’s typically <code>{ODBC Driver 18 for SQL Server}</code> or <code>{FreeTDS}</code> on Linux.</p>
<p>There’s also <code>SQLConnect</code> (simpler, uses DSN) vs <code>SQLDriverConnect</code> (connection string, like you’re used to). Always use <code>SQLDriverConnect</code> — DSNs are a relic.</p>
<hr />
<h2 id="executing-queries">3. Executing Queries</h2>
<h3 id="executenonquery-sqlexecdirect-sqlrowcount">ExecuteNonQuery → SQLExecDirect + SQLRowCount</h3>
<p><strong>C#:</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> cmd = <span class="kw">new</span> <span class="fu">SqlCommand</span>(<span class="st">&quot;DELETE FROM users WHERE inactive = 1&quot;</span>, conn);</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="dt">int</span> rowsAffected = cmd.<span class="fu">ExecuteNonQuery</span>();</span></code></pre></div>
<p><strong>ODBC C:</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>SQLHSTMT hstmt = SQL_NULL_HSTMT;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>ret = SQLExecDirect(hstmt,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    (SQLCHAR*)<span class="st">&quot;DELETE FROM users WHERE inactive = 1&quot;</span>, SQL_NTS);</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>SQLLEN rowCount = <span class="dv">0</span>;</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="cf">if</span> (ret == SQL_SUCCESS || ret == SQL_SUCCESS_WITH_INFO) {</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    SQLRowCount(hstmt, &amp;rowCount);</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    printf(<span class="st">&quot;Rows affected: %ld</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">long</span>)rowCount);</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>}</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span></code></pre></div>
<h3 id="executereader-sqlexecdirect-sqlfetch-sqlgetdata">ExecuteReader → SQLExecDirect + SQLFetch + SQLGetData</h3>
<p><strong>C#:</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> cmd = <span class="kw">new</span> <span class="fu">SqlCommand</span>(<span class="st">&quot;SELECT id, name FROM users&quot;</span>, conn);</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> reader = cmd.<span class="fu">ExecuteReader</span>();</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="kw">while</span> (reader.<span class="fu">Read</span>()) {</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    Console.<span class="fu">WriteLine</span>($<span class="st">&quot;{reader.GetInt32(0)}: {reader.GetString(1)}&quot;</span>);</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>ODBC C:</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>SQLHSTMT hstmt = SQL_NULL_HSTMT;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>ret = SQLExecDirect(hstmt, (SQLCHAR*)<span class="st">&quot;SELECT id, name FROM users&quot;</span>, SQL_NTS);</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>SQLINTEGER id;</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>SQLCHAR name[<span class="dv">256</span>];</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>SQLLEN id_ind, name_ind;</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="cf">while</span> (SQLFetch(hstmt) == SQL_SUCCESS) {</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">1</span>, SQL_C_LONG,  &amp;id,   <span class="kw">sizeof</span>(id),   &amp;id_ind);</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">2</span>, SQL_C_CHAR,  name,  <span class="kw">sizeof</span>(name), &amp;name_ind);</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>    printf(<span class="st">&quot;%d: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, id, name);</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>}</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span></code></pre></div>
<p>Note: <code>SQLExecDirect</code> is equivalent to sending the query. There’s no separate “reader” object — the statement handle <em>is</em> the reader. You fetch from it directly.</p>
<h3 id="executescalar-sqlexecdirect-sqlfetch-sqlgetdatacol-1">ExecuteScalar → SQLExecDirect + SQLFetch + SQLGetData(col 1)</h3>
<p><strong>C#:</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> cmd = <span class="kw">new</span> <span class="fu">SqlCommand</span>(<span class="st">&quot;SELECT COUNT(*) FROM users&quot;</span>, conn);</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="dt">int</span> count = (<span class="dt">int</span>)cmd.<span class="fu">ExecuteScalar</span>();</span></code></pre></div>
<p><strong>ODBC C:</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>SQLHSTMT hstmt = SQL_NULL_HSTMT;</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>ret = SQLExecDirect(hstmt, (SQLCHAR*)<span class="st">&quot;SELECT COUNT(*) FROM users&quot;</span>, SQL_NTS);</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>SQLINTEGER count = <span class="dv">0</span>;</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>SQLLEN ind;</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="cf">if</span> (SQLFetch(hstmt) == SQL_SUCCESS) {</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">1</span>, SQL_C_LONG, &amp;count, <span class="kw">sizeof</span>(count), &amp;ind);</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    printf(<span class="st">&quot;Count: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, count);</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>}</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span></code></pre></div>
<p>There’s no <code>ExecuteScalar</code> shortcut — it’s just “execute, fetch one row, read column 1.”</p>
<hr />
<h2 id="reading-results">4. Reading Results</h2>
<h3 id="the-fetch-loop">The Fetch Loop</h3>
<p><strong>C#:</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">while</span> (reader.<span class="fu">Read</span>()) {                          <span class="co">// returns bool</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="dt">string</span> name = reader.<span class="fu">GetString</span>(<span class="dv">0</span>);            <span class="co">// 0-based</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="dt">int</span> age = reader.<span class="fu">GetInt32</span>(<span class="dv">1</span>);</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    <span class="dt">bool</span> isNull = reader.<span class="fu">IsDBNull</span>(<span class="dv">2</span>);</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>ODBC C:</strong></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>SQLCHAR name[<span class="dv">256</span>];</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>SQLINTEGER age;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>SQLCHAR nullable_col[<span class="dv">256</span>];</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>SQLLEN name_ind, age_ind, nullable_ind;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="cf">while</span> (SQLFetch(hstmt) == SQL_SUCCESS) {          <span class="co">// returns SQL_SUCCESS or SQL_NO_DATA</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">1</span>, SQL_C_CHAR, name, <span class="kw">sizeof</span>(name), &amp;name_ind);    <span class="co">// 1-based!</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">2</span>, SQL_C_LONG, &amp;age,  <span class="kw">sizeof</span>(age),  &amp;age_ind);</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">3</span>, SQL_C_CHAR, nullable_col, <span class="kw">sizeof</span>(nullable_col), &amp;nullable_ind);</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    <span class="cf">if</span> (nullable_ind == SQL_NULL_DATA) {</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>        printf(<span class="st">&quot;Column 3 is NULL</span><span class="sc">\n</span><span class="st">&quot;</span>);             <span class="co">// IsDBNull equivalent</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>    }</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="method-mapping">Method Mapping</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>ADO.NET</th>
<th>ODBC</th>
<th>Watch Out</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>reader.Read()</code></td>
<td><code>SQLFetch(hstmt) == SQL_SUCCESS</code></td>
<td><code>SQL_NO_DATA</code> means end, not error</td>
</tr>
<tr class="even">
<td><code>reader.GetString(0)</code></td>
<td><code>SQLGetData(hstmt, 1, SQL_C_CHAR, buf, bufLen, &amp;ind)</code></td>
<td><strong>1-based</strong> column index</td>
</tr>
<tr class="odd">
<td><code>reader.GetInt32(0)</code></td>
<td><code>SQLGetData(hstmt, 1, SQL_C_LONG, &amp;val, sizeof(val), &amp;ind)</code></td>
<td><code>SQLINTEGER</code> is 32-bit</td>
</tr>
<tr class="even">
<td><code>reader.GetInt64(0)</code></td>
<td><code>SQLGetData(hstmt, 1, SQL_C_SBIGINT, &amp;val, sizeof(val), &amp;ind)</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>reader.GetDouble(0)</code></td>
<td><code>SQLGetData(hstmt, 1, SQL_C_DOUBLE, &amp;val, sizeof(val), &amp;ind)</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>reader.IsDBNull(0)</code></td>
<td>Check <code>ind == SQL_NULL_DATA</code> after <code>SQLGetData</code></td>
<td>No separate call — it’s a side effect</td>
</tr>
<tr class="odd">
<td><code>reader.GetOrdinal("Name")</code></td>
<td>No direct equivalent</td>
<td>Loop <code>SQLDescribeCol</code> to match by name (see Section 5)</td>
</tr>
</tbody>
</table>
<p>The <code>str_len_or_ind</code> parameter (the last argument to <code>SQLGetData</code>) serves double duty: it returns the length of the data <em>or</em> <code>SQL_NULL_DATA</code> (-1) if the column is null. This is the ODBC pattern for null-checking — there’s no separate <code>IsDBNull</code>.</p>
<p>For strings, if the data is longer than your buffer, <code>SQLGetData</code> returns <code>SQL_SUCCESS_WITH_INFO</code> and you need to call it again to get the rest. It’s like a streaming read. ADO.NET handles this internally with dynamic buffers.</p>
<hr />
<h2 id="column-metadata">5. Column Metadata</h2>
<p><strong>C#:</strong></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="dt">int</span> fieldCount = reader.<span class="fu">FieldCount</span>;</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fieldCount; i++) {</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="dt">string</span> name = reader.<span class="fu">GetName</span>(i);</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    Type type = reader.<span class="fu">GetFieldType</span>(i);</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>ODBC C:</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>SQLSMALLINT numCols;</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>SQLNumResultCols(hstmt, &amp;numCols);                <span class="co">// reader.FieldCount</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="cf">for</span> (SQLUSMALLINT i = <span class="dv">1</span>; i &lt;= numCols; i++) {     <span class="co">// 1-based!</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    SQLCHAR colName[<span class="dv">256</span>];</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    SQLSMALLINT colNameLen, dataType, decimalDigits, nullable;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    SQLULEN colSize;</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>    SQLDescribeCol(hstmt, i,</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>                   colName, <span class="kw">sizeof</span>(colName), &amp;colNameLen,</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>                   &amp;dataType,       <span class="co">// SQL_INTEGER, SQL_VARCHAR, etc.</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>                   &amp;colSize,        <span class="co">// e.g., 255 for VARCHAR(255)</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>                   &amp;decimalDigits,</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>                   &amp;nullable);      <span class="co">// SQL_NULLABLE, SQL_NO_NULLS</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>    printf(<span class="st">&quot;Column %d: %s (type=%d, size=%lu)</span><span class="sc">\n</span><span class="st">&quot;</span>,</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>           i, colName, dataType, (<span class="dt">unsigned</span> <span class="dt">long</span>)colSize);</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>SQLDescribeCol</code> gives you name + type in one call. For more detailed attributes (display size, auto-increment, etc.), use <code>SQLColAttribute</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>SQLLEN isAutoIncrement;</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>SQLColAttribute(hstmt, <span class="dv">1</span>, SQL_DESC_AUTO_UNIQUE_VALUE,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>                NULL, <span class="dv">0</span>, NULL, &amp;isAutoIncrement);</span></code></pre></div>
<h3 id="implementing-getordinal">Implementing GetOrdinal</h3>
<p>ODBC has no <code>GetOrdinal</code>. Roll your own:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>SQLUSMALLINT get_ordinal(SQLHSTMT hstmt, <span class="dt">const</span> <span class="dt">char</span>* target) {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    SQLSMALLINT numCols;</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    SQLNumResultCols(hstmt, &amp;numCols);</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    <span class="cf">for</span> (SQLUSMALLINT i = <span class="dv">1</span>; i &lt;= numCols; i++) {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>        SQLCHAR colName[<span class="dv">256</span>];</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>        SQLSMALLINT nameLen;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>        SQLDescribeCol(hstmt, i, colName, <span class="kw">sizeof</span>(colName), &amp;nameLen,</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>                       NULL, NULL, NULL, NULL);</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>        <span class="cf">if</span> (strcasecmp((<span class="dt">char</span>*)colName, target) == <span class="dv">0</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>            <span class="cf">return</span> i;</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>    }</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>; <span class="co">// not found</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>}</span></code></pre></div>
<hr />
<h2 id="parameters">6. Parameters</h2>
<h3 id="named-vs-positional">Named vs Positional</h3>
<p>ADO.NET uses named parameters (<code>@name</code>). ODBC uses positional markers (<code>?</code>). This is probably the single most annoying difference.</p>
<p><strong>C#:</strong></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> cmd = <span class="kw">new</span> <span class="fu">SqlCommand</span>(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>    <span class="st">&quot;INSERT INTO users (name, age) VALUES (@name, @age)&quot;</span>, conn);</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>cmd.<span class="fu">Parameters</span>.<span class="fu">AddWithValue</span>(<span class="st">&quot;@name&quot;</span>, <span class="st">&quot;Alice&quot;</span>);</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>cmd.<span class="fu">Parameters</span>.<span class="fu">AddWithValue</span>(<span class="st">&quot;@age&quot;</span>, <span class="dv">30</span>);</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>cmd.<span class="fu">ExecuteNonQuery</span>();</span></code></pre></div>
<p><strong>ODBC C:</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>SQLHSTMT hstmt = SQL_NULL_HSTMT;</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="co">// Prepare with ? markers (positional, not named)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>ret = SQLPrepare(hstmt,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>    (SQLCHAR*)<span class="st">&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;</span>, SQL_NTS);</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a><span class="co">// Bind parameter 1: name (VARCHAR)</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>SQLCHAR nameVal[] = <span class="st">&quot;Alice&quot;</span>;</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>SQLLEN nameInd = SQL_NTS;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>SQLBindParameter(hstmt, <span class="dv">1</span>, SQL_PARAM_INPUT,</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>                 SQL_C_CHAR, SQL_VARCHAR,</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>                 <span class="dv">50</span>,           <span class="co">// column size</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>                 <span class="dv">0</span>,            <span class="co">// decimal digits</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>                 nameVal, <span class="kw">sizeof</span>(nameVal), &amp;nameInd);</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a><span class="co">// Bind parameter 2: age (INTEGER)</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>SQLINTEGER ageVal = <span class="dv">30</span>;</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>SQLLEN ageInd = <span class="kw">sizeof</span>(ageVal);</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>SQLBindParameter(hstmt, <span class="dv">2</span>, SQL_PARAM_INPUT,</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>                 SQL_C_LONG, SQL_INTEGER,</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a>                 <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a>                 &amp;ageVal, <span class="kw">sizeof</span>(ageVal), &amp;ageInd);</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>ret = SQLExecute(hstmt);  <span class="co">// Execute the prepared statement</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span></code></pre></div>
<h3 id="key-differences">Key Differences</h3>
<ul>
<li><code>SQLPrepare</code> + <code>SQLExecute</code> is the ODBC equivalent of parameterized execution. <code>SQLExecDirect</code> doesn’t support bound parameters — you must prepare first.</li>
<li><code>SQLBindParameter</code> takes both the C type (<code>SQL_C_CHAR</code>) and the SQL type (<code>SQL_VARCHAR</code>). The driver does the conversion.</li>
<li>Parameters are bound to <em>buffers</em>. The driver reads the buffer at <code>SQLExecute</code> time, not at bind time. So you can rebind, change the value, and re-execute without re-preparing.</li>
<li>To pass NULL: set the indicator to <code>SQL_NULL_DATA</code>.</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>SQLLEN nullInd = SQL_NULL_DATA;</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>SQLBindParameter(hstmt, <span class="dv">1</span>, SQL_PARAM_INPUT,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>                 SQL_C_CHAR, SQL_VARCHAR,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>                 <span class="dv">50</span>, <span class="dv">0</span>, NULL, <span class="dv">0</span>, &amp;nullInd);</span></code></pre></div>
<blockquote>
<p><strong>furball note:</strong> Real ODBC drivers (like Microsoft’s) use TDS RPC calls for parameterized queries, sending parameter metadata and values separately. furball currently uses string substitution — it formats the parameter values into the SQL text before sending. This means parameterized queries in furball are syntactic sugar, not true parameterization. Something to keep in mind for testing.</p>
</blockquote>
<hr />
<h2 id="transactions">7. Transactions</h2>
<h3 id="c">C</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> tx = conn.<span class="fu">BeginTransaction</span>();</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="kw">try</span> {</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="kw">using</span> <span class="dt">var</span> cmd = <span class="kw">new</span> <span class="fu">SqlCommand</span>(<span class="st">&quot;UPDATE accounts SET balance = balance - 100 WHERE id = 1&quot;</span>, conn, tx);</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    cmd.<span class="fu">ExecuteNonQuery</span>();</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    <span class="kw">using</span> <span class="dt">var</span> cmd2 = <span class="kw">new</span> <span class="fu">SqlCommand</span>(<span class="st">&quot;UPDATE accounts SET balance = balance + 100 WHERE id = 2&quot;</span>, conn, tx);</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    cmd2.<span class="fu">ExecuteNonQuery</span>();</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>    tx.<span class="fu">Commit</span>();</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>} <span class="kw">catch</span> {</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    tx.<span class="fu">Rollback</span>();</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>    <span class="kw">throw</span>;</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="odbc-c">ODBC C</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">// Turn off autocommit (like BeginTransaction)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>SQLSetConnectAttr(hdbc, SQL_ATTR_AUTOCOMMIT,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>                  (SQLPOINTER)SQL_AUTOCOMMIT_OFF, <span class="dv">0</span>);</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>SQLHSTMT hstmt = SQL_NULL_HSTMT;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>ret = SQLExecDirect(hstmt,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>    (SQLCHAR*)<span class="st">&quot;UPDATE accounts SET balance = balance - 100 WHERE id = 1&quot;</span>,</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>    SQL_NTS);</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a><span class="cf">if</span> (ret != SQL_SUCCESS &amp;&amp; ret != SQL_SUCCESS_WITH_INFO) {</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>    SQLEndTran(SQL_HANDLE_DBC, hdbc, SQL_ROLLBACK);</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a>    <span class="cf">goto</span> cleanup;</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a>}</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a>ret = SQLExecDirect(hstmt,</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a>    (SQLCHAR*)<span class="st">&quot;UPDATE accounts SET balance = balance + 100 WHERE id = 2&quot;</span>,</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a>    SQL_NTS);</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a><span class="cf">if</span> (ret != SQL_SUCCESS &amp;&amp; ret != SQL_SUCCESS_WITH_INFO) {</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a>    SQLEndTran(SQL_HANDLE_DBC, hdbc, SQL_ROLLBACK);</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a>    <span class="cf">goto</span> cleanup;</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true"></a>}</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true"></a></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true"></a><span class="co">// Commit</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true"></a>SQLEndTran(SQL_HANDLE_DBC, hdbc, SQL_COMMIT);</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true"></a>cleanup:</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true"></a></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true"></a><span class="co">// Restore autocommit</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true"></a>SQLSetConnectAttr(hdbc, SQL_ATTR_AUTOCOMMIT,</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true"></a>                  (SQLPOINTER)SQL_AUTOCOMMIT_ON, <span class="dv">0</span>);</span></code></pre></div>
<p>ODBC defaults to autocommit ON — same as ADO.NET without an explicit transaction. <code>SQLEndTran</code> is how you commit or rollback. Note it takes the <em>connection</em> handle, not a statement handle.</p>
<p>You can reuse the same <code>HSTMT</code> for multiple queries within a transaction — unlike ADO.NET where each <code>SqlCommand</code> is a separate object. The statement handle is just an execution context.</p>
<hr />
<h2 id="error-handling">8. Error Handling</h2>
<h3 id="c-exceptions">C# — Exceptions</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">try</span> {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    cmd.<span class="fu">ExecuteNonQuery</span>();</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>} <span class="kw">catch</span> (SqlException ex) {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    Console.<span class="fu">WriteLine</span>($<span class="st">&quot;Error {ex.Number}: {ex.Message}&quot;</span>);</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>    Console.<span class="fu">WriteLine</span>($<span class="st">&quot;State: {ex.State}&quot;</span>);</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>    <span class="kw">foreach</span> (SqlError err <span class="kw">in</span> ex.<span class="fu">Errors</span>) {</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>        Console.<span class="fu">WriteLine</span>($<span class="st">&quot;  [{err.Class}] {err.Message}&quot;</span>);</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    }</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="odbc-return-codes-diagnostic-records">ODBC — Return Codes + Diagnostic Records</h3>
<p>Every ODBC function returns a <code>SQLRETURN</code>:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Return Code</th>
<th>Meaning</th>
<th>ADO.NET Equivalent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SQL_SUCCESS</code></td>
<td>All good</td>
<td>No exception</td>
</tr>
<tr class="even">
<td><code>SQL_SUCCESS_WITH_INFO</code></td>
<td>Worked, but there are warnings</td>
<td>No exception (info in <code>SqlConnection.InfoMessage</code>)</td>
</tr>
<tr class="odd">
<td><code>SQL_ERROR</code></td>
<td>Failed</td>
<td><code>SqlException</code> thrown</td>
</tr>
<tr class="even">
<td><code>SQL_NO_DATA</code></td>
<td>No more rows / no rows affected</td>
<td><code>reader.Read()</code> returns <code>false</code></td>
</tr>
<tr class="odd">
<td><code>SQL_INVALID_HANDLE</code></td>
<td>Bug — you passed a bad handle</td>
<td><code>NullReferenceException</code> vibes</td>
</tr>
</tbody>
</table>
<p>Here’s a reusable error extraction function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="dt">void</span> print_odbc_error(SQLSMALLINT handleType, SQLHANDLE handle) {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    SQLCHAR sqlState[<span class="dv">6</span>];</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    SQLINTEGER nativeError;</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>    SQLCHAR message[<span class="dv">1024</span>];</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    SQLSMALLINT messageLen;</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    SQLSMALLINT i = <span class="dv">1</span>;</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    <span class="cf">while</span> (SQLGetDiagRec(handleType, handle, i,</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>                         sqlState, &amp;nativeError,</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>                         message, <span class="kw">sizeof</span>(message), &amp;messageLen)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>           == SQL_SUCCESS)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>    {</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>        fprintf(stderr, <span class="st">&quot;[%s] (%d) %s</span><span class="sc">\n</span><span class="st">&quot;</span>, sqlState, nativeError, message);</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a>        i++;</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a>    }</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>Usage pattern:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>ret = SQLExecDirect(hstmt, (SQLCHAR*)<span class="st">&quot;SELECT * FROM nonexistent&quot;</span>, SQL_NTS);</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="cf">if</span> (ret == SQL_ERROR) {</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    print_odbc_error(SQL_HANDLE_STMT, hstmt);</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>    <span class="co">// Output: [42S02] (208) Invalid object name &#39;nonexistent&#39;.</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>The <code>SQLSTATE</code> is a 5-character code standardized by SQL/ISO. It’s like <code>SqlException.State</code> but more structured. <code>42S02</code> = table not found. <code>42000</code> = syntax error. <code>08001</code> = unable to connect. The <code>nativeError</code> is the SQL Server error number — same as <code>SqlException.Number</code>.</p>
<p>Multiple diagnostic records can exist (like <code>SqlException.Errors</code> having multiple entries). The <code>i</code> parameter to <code>SQLGetDiagRec</code> iterates through them, starting at 1.</p>
<hr />
<h2 id="schema-discovery">9. Schema Discovery</h2>
<h3 id="c-1">C</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>DataTable tables = conn.<span class="fu">GetSchema</span>(<span class="st">&quot;Tables&quot;</span>);</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>DataTable columns = conn.<span class="fu">GetSchema</span>(<span class="st">&quot;Columns&quot;</span>, <span class="kw">new</span>[] { <span class="kw">null</span>, <span class="kw">null</span>, <span class="st">&quot;users&quot;</span> });</span></code></pre></div>
<h3 id="odbc-catalog-functions">ODBC — Catalog Functions</h3>
<p>ODBC has dedicated functions that return result sets — you fetch from them exactly like a regular query.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>SQLHSTMT hstmt = SQL_NULL_HSTMT;</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="co">// List all tables (like GetSchema(&quot;Tables&quot;))</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>ret = SQLTables(hstmt,</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>    NULL, <span class="dv">0</span>,                  <span class="co">// catalog (database) — NULL = current</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>    NULL, <span class="dv">0</span>,                  <span class="co">// schema — NULL = all</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>    NULL, <span class="dv">0</span>,                  <span class="co">// table name — NULL = all</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>    (SQLCHAR*)<span class="st">&quot;TABLE&quot;</span>, SQL_NTS);  <span class="co">// table type filter</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a><span class="co">// Fetch results — same pattern as any query</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>SQLCHAR tableName[<span class="dv">256</span>];</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>SQLLEN ind;</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a><span class="cf">while</span> (SQLFetch(hstmt) == SQL_SUCCESS) {</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">3</span>, SQL_C_CHAR, tableName, <span class="kw">sizeof</span>(tableName), &amp;ind);</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a>    printf(<span class="st">&quot;Table: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, tableName);</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>}</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">// List columns for a specific table (like GetSchema(&quot;Columns&quot;))</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>ret = SQLColumns(hstmt,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>    NULL, <span class="dv">0</span>,                     <span class="co">// catalog</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>    NULL, <span class="dv">0</span>,                     <span class="co">// schema</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>    (SQLCHAR*)<span class="st">&quot;users&quot;</span>, SQL_NTS,  <span class="co">// table name</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>    NULL, <span class="dv">0</span>);                    <span class="co">// column name — NULL = all</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>SQLCHAR colName[<span class="dv">256</span>];</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a>SQLSMALLINT dataType;</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a>SQLLEN colNameInd, dataTypeInd;</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a><span class="cf">while</span> (SQLFetch(hstmt) == SQL_SUCCESS) {</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">4</span>, SQL_C_CHAR, colName, <span class="kw">sizeof</span>(colName), &amp;colNameInd);</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true"></a>    SQLGetData(hstmt, <span class="dv">5</span>, SQL_C_SHORT, &amp;dataType, <span class="kw">sizeof</span>(dataType), &amp;dataTypeInd);</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true"></a>    printf(<span class="st">&quot;Column: %s (type: %d)</span><span class="sc">\n</span><span class="st">&quot;</span>, colName, dataType);</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true"></a>}</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span></code></pre></div>
<p>Full list of catalog functions:</p>
<table>
<thead>
<tr class="header">
<th>ODBC Function</th>
<th>ADO.NET Equivalent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SQLTables</code></td>
<td><code>GetSchema("Tables")</code></td>
</tr>
<tr class="even">
<td><code>SQLColumns</code></td>
<td><code>GetSchema("Columns")</code></td>
</tr>
<tr class="odd">
<td><code>SQLPrimaryKeys</code></td>
<td><code>GetSchema("IndexColumns")</code> with PK filter</td>
</tr>
<tr class="even">
<td><code>SQLForeignKeys</code></td>
<td><code>GetSchema("ForeignKeys")</code></td>
</tr>
<tr class="odd">
<td><code>SQLGetTypeInfo</code></td>
<td><code>GetSchema("DataTypes")</code></td>
</tr>
<tr class="even">
<td><code>SQLStatistics</code></td>
<td><code>GetSchema("Indexes")</code></td>
</tr>
<tr class="odd">
<td><code>SQLProcedures</code></td>
<td><code>GetSchema("Procedures")</code></td>
</tr>
<tr class="even">
<td><code>SQLProcedureColumns</code></td>
<td><code>GetSchema("ProcedureParameters")</code></td>
</tr>
</tbody>
</table>
<p>These all return well-defined result set schemas documented in the ODBC spec. Column positions are standardized — e.g., <code>SQLTables</code> always returns TABLE_CAT in column 1, TABLE_SCHEM in column 2, TABLE_NAME in column 3, etc.</p>
<hr />
<h2 id="cleanup">10. Cleanup</h2>
<h3 id="c-using-dispose">C# — <code>using</code> / <code>Dispose()</code></h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> conn = <span class="kw">new</span> <span class="fu">SqlConnection</span>(connStr);</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> cmd = conn.<span class="fu">CreateCommand</span>();</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">var</span> reader = cmd.<span class="fu">ExecuteReader</span>();</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="co">// Everything cleaned up automatically in reverse order</span></span></code></pre></div>
<h3 id="odbc-manual-sqlfreehandle">ODBC — Manual <code>SQLFreeHandle</code></h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="co">// Free in reverse order of allocation</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  <span class="co">// Free statement first</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>SQLDisconnect(hdbc);                     <span class="co">// Disconnect before freeing</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_DBC, hdbc);     <span class="co">// Free connection</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>SQLFreeHandle(SQL_HANDLE_ENV, henv);     <span class="co">// Free environment last</span></span></code></pre></div>
<p>Order matters. Freeing a connection handle before its statement handles is undefined behavior. Think of it like <code>Dispose()</code> — you wouldn’t dispose a <code>SqlConnection</code> while a <code>SqlDataReader</code> is still open (well, you <em>can</em> in ADO.NET because it handles the cascade, but in ODBC you do it yourself).</p>
<p>A full program skeleton:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sql.h&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sqlext.h&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>    SQLHENV henv = SQL_NULL_HENV;</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>    SQLHDBC hdbc = SQL_NULL_HDBC;</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>    SQLHSTMT hstmt = SQL_NULL_HSTMT;</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>    SQLRETURN ret;</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>    <span class="co">// Setup</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true"></a>    SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true"></a>    SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, <span class="dv">0</span>);</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true"></a>    SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true"></a>    SQLCHAR connStr[] = <span class="st">&quot;DRIVER={ODBC Driver 18 for SQL Server};&quot;</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true"></a>                        <span class="st">&quot;SERVER=localhost;DATABASE=mydb;&quot;</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true"></a>                        <span class="st">&quot;UID=sa;PWD=secret;&quot;</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true"></a>                        <span class="st">&quot;TrustServerCertificate=yes;&quot;</span>;</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true"></a>    ret = SQLDriverConnect(hdbc, NULL, connStr, SQL_NTS,</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true"></a>                           NULL, <span class="dv">0</span>, NULL, SQL_DRIVER_NOPROMPT);</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true"></a>    <span class="cf">if</span> (ret != SQL_SUCCESS &amp;&amp; ret != SQL_SUCCESS_WITH_INFO) {</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true"></a>        fprintf(stderr, <span class="st">&quot;Connect failed</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true"></a>        <span class="cf">goto</span> cleanup;</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true"></a>    }</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true"></a></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true"></a>    <span class="co">// Work</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true"></a>    SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true"></a>    ret = SQLExecDirect(hstmt, (SQLCHAR*)<span class="st">&quot;SELECT @@VERSION&quot;</span>, SQL_NTS);</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true"></a>    <span class="cf">if</span> (ret == SQL_SUCCESS) {</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true"></a>        SQLCHAR version[<span class="dv">1024</span>];</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true"></a>        SQLLEN ind;</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true"></a>        <span class="cf">if</span> (SQLFetch(hstmt) == SQL_SUCCESS) {</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true"></a>            SQLGetData(hstmt, <span class="dv">1</span>, SQL_C_CHAR, version, <span class="kw">sizeof</span>(version), &amp;ind);</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true"></a>            printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, version);</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true"></a>        }</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true"></a>    }</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true"></a></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true"></a>cleanup:</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true"></a>    <span class="cf">if</span> (hstmt != SQL_NULL_HSTMT) SQLFreeHandle(SQL_HANDLE_STMT, hstmt);</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true"></a>    <span class="cf">if</span> (hdbc != SQL_NULL_HDBC) {</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true"></a>        SQLDisconnect(hdbc);</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true"></a>        SQLFreeHandle(SQL_HANDLE_DBC, hdbc);</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true"></a>    }</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true"></a>    <span class="cf">if</span> (henv != SQL_NULL_HENV) SQLFreeHandle(SQL_HANDLE_ENV, henv);</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true"></a></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true"></a>}</span></code></pre></div>
<p>Compile with: <code>gcc -o example example.c -lodbc</code></p>
<hr />
<h2 id="quick-reference-table">11. Quick Reference Table</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>ADO.NET</th>
<th>ODBC</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SqlConnection</code></td>
<td><code>HDBC</code> + <code>SQLDriverConnect</code></td>
<td>ODBC also needs <code>HENV</code> allocated first</td>
</tr>
<tr class="even">
<td><code>SqlCommand</code></td>
<td><code>HSTMT</code> + <code>SQLExecDirect</code> / <code>SQLPrepare</code> + <code>SQLExecute</code></td>
<td>Statement handle <em>is</em> the command</td>
</tr>
<tr class="odd">
<td><code>SqlDataReader</code></td>
<td><code>HSTMT</code> + <code>SQLFetch</code> + <code>SQLGetData</code></td>
<td>Same handle as the command — no separate reader</td>
</tr>
<tr class="even">
<td><code>SqlParameter</code></td>
<td><code>SQLBindParameter</code></td>
<td>Positional <code>?</code> markers, not <code>@name</code></td>
</tr>
<tr class="odd">
<td><code>SqlTransaction</code></td>
<td><code>SQLSetConnectAttr(AUTOCOMMIT OFF)</code> + <code>SQLEndTran</code></td>
<td>No transaction object — it’s connection-level state</td>
</tr>
<tr class="even">
<td><code>SqlException</code></td>
<td><code>SQLGetDiagRec</code></td>
<td>Must call after every failed return code</td>
</tr>
<tr class="odd">
<td><code>reader.Read()</code></td>
<td><code>SQLFetch()</code></td>
<td>Returns <code>SQL_SUCCESS</code> / <code>SQL_NO_DATA</code></td>
</tr>
<tr class="even">
<td><code>reader.GetString(i)</code></td>
<td><code>SQLGetData(i+1, SQL_C_CHAR, ...)</code></td>
<td>0-based → 1-based</td>
</tr>
<tr class="odd">
<td><code>reader.FieldCount</code></td>
<td><code>SQLNumResultCols</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>reader.GetName(i)</code></td>
<td><code>SQLDescribeCol(i+1, ...)</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>conn.GetSchema()</code></td>
<td><code>SQLTables</code> / <code>SQLColumns</code> / etc.</td>
<td>Return result sets</td>
</tr>
<tr class="even">
<td><code>cmd.ExecuteNonQuery()</code></td>
<td><code>SQLExecDirect</code> + <code>SQLRowCount</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>cmd.ExecuteScalar()</code></td>
<td><code>SQLExecDirect</code> + <code>SQLFetch</code> + <code>SQLGetData(1, ...)</code></td>
<td>No shortcut — manual</td>
</tr>
<tr class="even">
<td><code>using</code> / <code>Dispose()</code></td>
<td><code>SQLFreeHandle</code></td>
<td>Manual, reverse order</td>
</tr>
<tr class="odd">
<td><code>conn.Open()</code></td>
<td><code>SQLDriverConnect</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>conn.Close()</code></td>
<td><code>SQLDisconnect</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>Connection pooling</code></td>
<td><em>(Driver Manager may pool)</em></td>
<td>Not guaranteed; DM-dependent</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="key-gotchas-for-ado.net-developers">12. Key Gotchas for ADO.NET Developers</h2>
<ol type="1">
<li><p><strong>1-based column indexing.</strong> ODBC columns start at 1. ADO.NET starts at 0. You <em>will</em> get this wrong at least once. <code>SQLGetData(hstmt, 0, ...)</code> is invalid.</p></li>
<li><p><strong>Manual memory management.</strong> You provide the buffers for <code>SQLGetData</code>. If your buffer is too small, you get truncated data with <code>SQL_SUCCESS_WITH_INFO</code>. There’s no auto-growing <code>string</code> — you’re in C, you manage memory.</p></li>
<li><p><strong>No built-in connection pooling.</strong> The ODBC Driver Manager <em>may</em> implement pooling (<code>SQLSetEnvAttr(SQL_ATTR_CONNECTION_POOLING)</code>), but it’s not the robust, well-tested pool you get in ADO.NET. Many applications roll their own.</p></li>
<li><p><strong>Parameter markers are <code>?</code>, not <code>@name</code>.</strong> They’re positional. If you have <code>INSERT INTO t (a, b) VALUES (?, ?)</code>, the first <code>SQLBindParameter(..., 1, ...)</code> binds to the first <code>?</code>. No names. Reordering markers means rebinding.</p></li>
<li><p><strong>Check return codes on every call.</strong> There are no exceptions. If you skip checking, you’ll silently proceed with failed operations. Develop a macro:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="pp">#define CHECK_ODBC(fn, handleType, handle) do { \</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="pp">    SQLRETURN _r = (fn);                        \</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a><span class="pp">    if (_r == SQL_ERROR) {                      \</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a><span class="pp">        print_odbc_error(handleType, handle);   \</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a><span class="pp">        goto cleanup;                           \</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a><span class="pp">    }                                           \</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a><span class="pp">} while(0)</span></span></code></pre></div></li>
<li><p><strong>W-functions vs A-functions.</strong> <code>SQLExecDirect</code> takes <code>SQLCHAR*</code> (ANSI). <code>SQLExecDirectW</code> takes <code>SQLWCHAR*</code> (UTF-16). On Windows, the Driver Manager can convert between them. On Linux with unixODBC, the DM also does conversion. Know which encoding your driver expects. For SQL Server, the wire protocol is UTF-16 (UCS-2 technically), so using W-functions avoids a conversion hop.</p></li>
<li><p><strong><code>SQL_NTS</code> means null-terminated string.</strong> Whenever you pass a string length, you can pass <code>SQL_NTS</code> instead of the actual byte count, and ODBC will <code>strlen</code> it for you. Convenient, but means your strings must actually be null-terminated.</p></li>
<li><p><strong>No <code>NextResult</code>.</strong> Well, there is — it’s <code>SQLMoreResults</code>. If your query returns multiple result sets, call <code>SQLMoreResults(hstmt)</code> to advance. Returns <code>SQL_SUCCESS</code> if there’s another result set, <code>SQL_NO_DATA</code> if done.</p></li>
<li><p><strong>Statement handle reuse.</strong> Unlike ADO.NET where you typically create a new <code>SqlCommand</code> per query, in ODBC it’s common to reuse statement handles. After fetching all results, you can call <code>SQLFreeStmt(hstmt, SQL_CLOSE)</code> to close the cursor without freeing the handle, then execute another query on the same handle.</p></li>
<li><p><strong>No async/await.</strong> ODBC has <code>SQL_ASYNC_ENABLE</code> but it’s polling-based, not callback-based. In practice, almost nobody uses it. If you need async, you do it at the application layer (threads, event loops, etc.).</p></li>
</ol>
</body>
</html>
